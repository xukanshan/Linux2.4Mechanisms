#ifndef _LINUX_SERIAL_H
#define _LINUX_SERIAL_H

/* 在Linux内核中，特别是在串行通信的上下文中，serial.h 文件通常包含了与串行端口相关的宏定义、结构和函数声明 */

/* 在驱动程序开发中，我们常常看到分为xxx.h和xxxP.h的情况，这里的xxx代表某个特定的模块或功能，比如serial。
serial.h：这个文件通常包含公共接口、定义和外部可见的结构。也就是说，如果其他的代码模块需要与串行驱动程序交互，它们会包括serial.h。
这个头文件将声明那些需要被外部访问的函数、宏、结构和符号。
serialP.h：文件名中的"P"通常代表“私有”（Private），意味着该文件中的内容是私有的，仅限于串行驱动本身内部使用。
它可能包含私有的数据结构定义、内部函数原型、私有宏等。这些内容不是给外部模块使用的，而是用于驱动程序内部实现的细节。
为什么需要这样分离呢？以下是一些理由：
封装：通过将内部和外部的接口分开，可以更好地封装代码，避免内部实现细节被外部代码错误地依赖或修改。
编译依赖性：外部代码不需要知道驱动程序内部的所有细节，这样可以减少编译时的依赖性，加快编译速度，也减少了头文件更改时全局重编译的需要。
维护性：这样的分离使得开发者能够更清晰地看到哪些部分是公共接口，哪些部分是内部实现。如果需要改动内部实现，不会影响到依赖于公共接口的外部代码。
稳定性和兼容性：公共接口的变更通常需要更谨慎，因为它们可能会影响到依赖于这些接口的其他代码。而内部实现则可以更自由地变动，只要保证不破坏公共接口的行为即可。
因此，即使include/linux下有serial.h，serialP.h也是必要的，以隔离公共接口和私有实现，保持内核代码的整洁和可维护性。 */

/* 通过以下这些定义，内核中的串行驱动代码可以区分不同类型的串行端口，从而采用正确的方法来访问相应的硬件资源 */
/* 这表示串行接口是通过常规的I/O端口进行访问的。这是最传统的访问方式，使用IN和OUT指令（在x86架构上）进行端口I/O操作。 */
#define SERIAL_IO_PORT 0

/* HUB6是一种专门的串行卡，能够扩展多个串行端口。
SERIAL_IO_HUB6 表示这个串行端口是HUB6硬件的一部分，这通常意味着访问这些端口需要特殊的方式或协议。 */
/* #define SERIAL_IO_HUB6 1 */

/* 当串行接口的控制寄存器被映射到内存地址空间时使用这个定义。许多现代硬件设备都是通过内存映射的方式来访问控制寄存器，而不是传统的I/O端口。 */
#define SERIAL_IO_MEM 2

/* GSC代表一种特定的总线类型（General System Controller），
这是惠普（HP）的PA-RISC系统上使用的。如果一个串行端口是通过GSC总线访问的，那么它将使用这个定义。 */
/* #define SERIAL_IO_GSC 3 */

#endif /* _LINUX_SERIAL_H */